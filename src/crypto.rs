/*
    Copyright Â© 2023, ParallelChain Lab 
    Licensed under the Apache License, Version 2.0: http://www.apache.org/licenses/LICENSE-2.0
*/

use rs_merkle::{MerkleTree, algorithms::Sha256};
use crate::Serializable;

/// An Ed25519 signature. These are generated by external accounts to authorize transactions,
/// and by validators to create proposals and cast votes during consensus.
pub type Signature = [u8; 64];

/// An Ed25519 secret key. These are used to produce Ed25519 signatures. 
pub type SecretKey = [u8; 32];

/// PublicAddress is either:
/// - an Ed25519 public key representing an external account, or
/// - a contract address.
pub type PublicAddress = [u8; 32];

/// A SHA256 hash. Used as block and transaction hashes, as well as to form Merkle tries.
pub type Sha256Hash = [u8; 32];

/// A space-efficient probabilistic data structure
pub type BloomFilter = [u8; 256];

// Computes the Merkle root hash of a vector of serializable data.
pub fn merkle_root<B: Serializable>(data: &Vec<B>) -> Sha256Hash {
    fn serialize_and_sha256<D: Serializable>(datum: &D) -> Sha256Hash {
            let r = <D as Serializable>::serialize(datum);
            sha256(&r)
    }

    // null hash really isn't all 0s. There is no hash value for a tree without root. But here 
    // we use the 32-byte hash values to fill in the field definition inside data structures, for example, block header.
    if data.is_empty() {
        return [0; 32]
    }

    let leaves: Vec<[u8; 32]> = data
        .iter()
        .map(|datum| serialize_and_sha256::<B>(datum))
        .collect();
    let merkle_tree = MerkleTree::<Sha256>::from_leaves(&leaves);
    merkle_tree.root().unwrap()
}

/// Compute a Sha256 hash.
pub fn sha256(data: &[u8]) -> Sha256Hash {
    use sha2::{Sha256, Digest};
    let mut ret = Sha256::new();
    ret.update(data);
    ret.finalize().into()
}


pub trait AsKeyPair {
    fn as_keypair(&self) -> Result<ed25519_dalek::Keypair, CryptographicallyIncorrectTransactionError>;
}

impl AsKeyPair for [u8] {
    fn as_keypair(&self) -> Result<ed25519_dalek::Keypair, CryptographicallyIncorrectTransactionError> {
        ed25519_dalek::Keypair::from_bytes(self).map_err(|_| {CryptographicallyIncorrectTransactionError::InvalidKeypair})
    }
}

#[derive(Debug)]
pub enum CryptographicallyIncorrectTransactionError {
    InvalidFromAddress,
    InvalidKeypair,
    InvalidSignature,
    WrongSignature,
    WrongHash,
}